
= 命名空间
:sectnums:
:toclevels: 3
:toc: left

---

== 命名空间

在一个命名空间中声明的类的名称, 与另一个命名空间中声明的相同的类的名称, 不冲突。 正如同 一个文件夹(目录)中可以包含多个文件夹，每个文件夹中不能有相同的文件名，但不同文件夹中的文件可以重名。

命名空间的定义是以关键字 namespace 开始，后跟命名空间的名称，如下所示：

[,subs=+quotes]
----
namespace namespace_name
{
   // 代码声明
}
----


为了调用支持命名空间版本的函数或变量，会把命名空间的名称置于前面，如下所示：
[,subs=+quotes]
----
namespace_name.item_name;
----



你的"类"写在A命名空间中, 则只能在A空间中能被访问到. 而不能被其他命名空间看到.

[source, java]
----
namespace  S1
{
  class Person { }
}

namespace S2
{
  Person p = new Person();   //我们想调用Person类, 但这个类, 我们是写在 S1命名空间中的, 而不在现在的 S2命名空间中. 所以无法调用, 会报错.
}
----

== 命名空间, 可以嵌套

[source, java]
----
using ConsoleApp2.myNameSpace1;

namespace ConsoleApp2
{

    namespace myNameSpace1 //命名空间, 使用来管理"类"的. 命名空间可以嵌套, 比如这里, 这个 myNameSpace1 命名空间, 就位于 ConsoleApp2 命名空间的内部.
    {
        class Cls命名空间1里面的类 //
        {

        }
    }

    internal class Program
    {
        static void Main(string[] args)
        {

            myNameSpace1.Cls命名空间1里面的类 cls1 = new myNameSpace1.Cls命名空间1里面的类(); //调用时, 可以带上命名空间名, 来调用里面的类.

        }

    }
}
----

image:/img/0082.png[,]

在同一个项目的不同文件中, 有不同的"命名空间"(来管理里面的类), 也可以通过 using来引用该"命名空间"后, 就能调用里面的类.

image:/img/0083.png[,]


---

== 在一个项目中,引用另一个项目中的类

image:/img/0146.png[,]

我们在项目1上, 对依赖项, 右键, 添加引用

image:/img/0147.png[,]

image:/img/0148.png[,]


然后, 你就可以在项目1的main函数中, 调用项目2中的类了.

[,subs=+quotes]
----
using Newtonsoft.Json;
using System.Diagnostics;
*using ConsoleApp2; //引用另一个项目的命名空间*

namespace ConsoleApp1
{
    internal class Program
    {

        static void Main(string[] args)
        {
            *ClsTest insT = new ClsTest(); //ClsTest是项目2 (即 ConsoleApp2 命名空间)中的类.*
        }
----


但注意: 项目2中的类, 必须是 public的, 而不能是 internal的, 否则, internal的类依然是不对外暴露的.



[,subs=+quotes]
----
namespace ConsoleApp2
{
    *internal* class ClsState状态机  *//internal 修饰的类, 不会被暴露出去. 它要改成 public才行.*
    {

    }
}
----


我们都知道的三种类型/成员修饰符public、protected、private，也明白它们所表示的含义，**internal也是一各类型/成员修饰符（被修饰的类型或者成员称为内部类型或成员），只是它所修饰的类只能在同一个程序集中被访问，**而同一个程序集表示同一个dll程序集或同一个exe程序集。*在vs中一个项目会生成一个dll文件，因此这个dll或这个项目也就是一个程序集。*

内部访问通常用于基于组件的开发，因为它使一组组件能够以私有方式进行合作，而不必向应用程序代码的其余部分公开。

进入主题之前先来了解一下，项目、解决方案、程序集、命名空间四个容易混淆的概念。
①**项目：就是我们开发的一个软件。.NET下，项目有多种类型，如控制台、Windows应用程序、类库、Web应用程序等等。经过编译后，会生成.exe文件和.dll文件。 **

.exe文件有统一的主程序入口，
可以被执行，而类库只是提供一些功能给其他项目调用。

②解决方案：当我们在VS中新建任何一种类型项目时，这个项目还属于一个解决方案。*当我们的业务相对简单时，解决方案所发挥的作用并不是很大。但当我们开发复杂的软件时，需要多个模块组成。*

比如说开发中常用的三层架构，U层是一个简单的windows应用程序（项目的一种类型）、B、D层由多个类库(项目的另一种类型)组成。通过一个解决方案，我们就可以将其(多个项目)组合起来，完成我们的开发。

形象地说，解决方案就是一个容器，在这个容器里，分成好多层，好多格，用来存放不同的项目。换句话来说：就是《*程序集就是一个项目，多个项目构成一个解决方案*》

③*程序集：一个项目就是一个程序集。一个程序集可以体现为一个dll文件，或者exe文件。*

④命名空间：主要是为了避免一个项目中，可能会存在的相同对象名的冲突。


1.internal（内部）：限定的是只有在同一程序集中可访问，可以跨类
    protected（受保护）：限定的是只有在继承的子类中可访问，可以跨程序集
    protected

internal：受保护“或”内部修饰符修饰成员,当父类与子类在同一个程序集中，internal成员可见。当父类与子类不在同一个程序集中，子类不能访问父类internal成员，

而子类可以访问父类的ptotected
 internal成员，
即从当前程序集或从包含类派生的类型，可以访问具有访问修饰符 protected internal 的类型或成员。

2.internal 关键字是类型和类型的成员 访问修饰符。只有在同一程序集的文件中，内部类型或成员才是可访问的

内部访问通常用于基于组件的开发，因为它使一组组件能够以私有方式进行合作，而不必向应用程序代码的其余部分公开。
例如，用于生成图形用户界面的框架可以提供 Control 和 Form 类，这两个类通过使用具有内部访问权限的成员进行合作。
由于这些成员是内部的，它们不向正在使用框架的代码公开。

3.从定义具有内部访问能力的类型或成员的程序集外部引用该类型或成员是错误的。


'''


