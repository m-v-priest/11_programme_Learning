
= 接口
:sectnums:
:toclevels: 3
:toc: left

---







== SOLID原则

SOLID原则, 包括5个子原则:


=== "单一职责"原则 (SRP) Single Responsibility Principle

一个类，最好只负责一件事，只有一个引起它变化的原因。 +
There should never be more than one reason for a class to change。



单一职责通常意味着单一的功能，因此不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。



'''


=== Open Close Principle，开闭原则

软件实体（包括类、模块、功能等）应该对扩展开放，但是对修改关闭。 +
Software entities (classes, modules, functions) should be open for extension /but closed for modification。

对修改关闭, 就是说，应该尽量在不修改源代码的基础上面, 扩展组件。因为修改已经存在的源代码是存在很大风险的.  +
在别人的代码上面改功能，做过开发的都知道，苦不堪言，因为你不知道别人哪里会给你埋一个“坑”。 +
在现有代码上面改，也存在很大的风险，即使做好之后, 所有的功能都必须重新经过严格的测试.


不允许修改源代码，那我们如何应对需求变更呢？答案就是"对扩展开放". 这要求我们必须要"面向接口编程"，或者说"面向抽象编程"。所有参数类型、引用传递的对象, 必须使用抽象（接口或者抽象类）的方式定义。




'''

=== Liskov Substitution Principle，里氏替换原则

[options="autowidth"]
|===
|Header 1 |Header 2

|里氏代换原则：
|任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。

|1.子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法. *子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。*
|**在我们做系统设计时，经常会设计接口或抽象类，然后由子类来实现抽象方法，**这里使用的其实就是里氏替换原则。

里氏替换原则的关键点在于: 不能覆盖父类的非抽象方法。 *父类中凡是已经实现好的方法，实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些规范，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。* +
如果通过重写父类的方法来完成新的功能，整个继承体系的可复用性就会比较差.


|2.子类中, 可以增加自己特有的方法.
|当功能扩展时，子类尽量不要重写父类的方法，而是另写一个新方法.

|3.当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）, 要比父类方法的输入参数更宽松.
|
|===







'''

=== "接口隔离"原则(ISP) Interface Segregation Principle

"接口隔离原则"指出:

==== (1) 不应该强行要求客户端依赖于它们不用的接口. 

Clients should not be forced to depend upon interfaces that they don't use.

反过来说，*如果客户端依赖了它们不需要的接口，那么这些客户端程序, 就面临不需要的接口变更引起的客户端变更的风险，* 这样就会增加客户端和接口之间的耦合程度，显然与“高内聚、低耦合”的思想相矛盾。


'''


==== (2) 类之间的依赖, 应该建立在最小的接口上面.

The dependency of one class to another one /should depend on the smallest possible interface.

这里最小的粒度, 取决于"单一职责原则"的划分.

image:img/0179.png[,]

image:img/0180.png[,]




'''

=== Dependency Inversion Principle，依赖倒置原则



'''










image:img/0165.png[,]









一般, 我们习惯在"接口"的变量名中, 加个 "IF", 表示它是 interface类型.

- 接口中, 一般只包含"方法". 并且, 接口中只包含方法的声明, 而没有方法的实现.
接口中, 只做了成员的声明, 而没有定义(没有具体的函数体). 成员的定义是派生类的责任。接口只是提供了派生类应遵循的标准结构。
- 接口本身并不实现任何功能，它只是和声明"实现该接口"的对象, 订立一个必须实现哪些行为的契约。
- 接口不能有"构造函数"，也不能有字段，接口也不允许运算符重载。
- 接口定义中不允许声明成员的修饰符，接口成员都是公有的.


创建一个接口:

image:img/0034.png[,]

image:img/0035.png[,]






'''

== IEnumerable 接口

*C#常用集合, 都实现了ICollection 和 IEnumerable接口，这是能使用foreach的关键所在。*

image:img/0157.png[,]


而我们自定义的集合，**IEnumerable中定义了一个GetEnumerator()方法，IEnumerator 依靠MoveNext() 和 Current, 来达到Foreach的遍历。** +
*第一次遇到foreach里的对象时, 就会去执行继承IEnumerable类中的GetEnumerator()方法，接着每次执行in关键字, 就会去执行MoveNext()方法，每次取数据则是调用Current属性。*

IEnumerable接口, 并不是我们看到的只有一个方法，它还有4个扩展方法。其中Cast<T>()和OfType<T>()这2个方法, 非常实用。

*有时候对于非泛型集合比如ArrayList，它只实现了IEnumerable接口, 而没有实现IEnumerable<T>接口，因此无法使用标准查询运算。*

*IEnumerable接口是非常的简单，只包含一个抽象的方法GetEnumerator()，它返回一个可用于循环访问集合的IEnumerator对象。对于所有数组的遍历，都来自IEnumerable接口。*

**IEnumerator对象有什么呢？它是一个真正的集合访问器，没有它，就不能使用foreach语句遍历集合或数组，因为只有IEnumerator对象才能访问集合中的项，**假如连集合中的项都访问不了，那么进行集合的循环遍历是不可能的事情了。



'''


== 依赖反转

类与类之间的分工合作, 叫做"依赖",


在软件系统中，类不是孤立存在的，类与类之间存在各种关系。根据类与类之间的耦合度从弱到强排列，UML 中的类图有以下几种关系：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的。

依赖关系

**依赖（Dependency）关系, 是一种"使用关系"，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。**在代码中，某个类的方法, 通过局部变量、方法的参数, 或者对静态方法的调用, 来访问另一个类（被依赖类）中的某些方法, 来完成一些职责。

特点：

1：是一种使用关系 +
2：是一种临时关系

**在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。**如下图所示是人与手机的关系图，人通过手机的语音传送方法打电话。 *(人类, 只是借用你手机实例, 来实现打电话(函数方法)的目的,  而不是把你手机实例嵌入在我的类里面.)*

image:img/0158.png[,]




关联关系
关联（Association）关系是对象之间的一种引用关系，**用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。**关联关系是类与类之间最常用的一种关系，*分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。*

特点：
1：是一种引用关系
2：可以是双向的
3：可以是单向的

**在 UML 类图中，双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。**也可以在关联线的两端标注角色名，代表两种不同的角色。

**在代码中, 通常将一个类的对象, 作为另一个类的成员变量, 来实现关联关系。**如下图所示是老师和学生的关系图，*每个老师可以教多个学生，每个学生也可向多个老师学，他们是双向关联。  (你的类型实例, 嵌入到我的字段中, 而且是互相嵌入, 你中有我, 我中有你.)*

image:img/0159.png[,]



聚合关系

聚合（Aggregation）关系是关联关系的一种，*是强关联关系，是整体和部分之间的关系，是 has-a 的关系。*

*聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。 (单项嵌入)*

特点：
1：是一种强关联关系
2：是一种拥有的关系

在 UML 类图中，**聚合关系可以用带空心菱形的实线来表示，菱形指向整体。**如下图所示是大学和教师的关系图。

image:img/0160.png[,]

组合关系

*组合（Composition）关系, 也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 contains-a 关系。*

在组合关系中，*整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。*

特点：
1：是一种强关联关系
2：是一种包含的关系
3： 整体对象控制部分对象的生命周期

在 UML 类图中，**组合关系用"带实心菱形的实线"来表示，菱形指向整体。**如下图所示是头和嘴的关系图。

image:img/0161.png[,]


泛化关系

泛化（Generalization）关系, **是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。*

特点：
1：是对象间耦合度最大的一种关系
2：是一种继承关系

在 UML 类图中，**泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。**

**在代码实现时，使用面向对象的"继承"机制, 来实现泛化关系。**例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示。

image:img/0162.png[,]


实现关系
**实现关系 Realization, 是接口与实现类之间的关系。**在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。

特点：
1：*耦合度最大的一种关系*
2：是一种继承关系

**在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。**例如，汽车和船实现了交通工具，其类图如下图所示。

image:img/0163.png[,]



什么是依赖和耦合

　　依赖，就是关系，代表了软件实体之间的联系。软件的实体可能是模块，可能是层次，也可能是具体的类型，**不同的实体直接发生依赖，也就意味着发生了耦合。**所以，依赖和耦合在我看来是对一个问题的两种表达，依赖阐释了耦合本质，而耦合量化了依赖程度。因此，对于关系的描述方式，就可以从两个方面的观点来分析。

　　从依赖的角度而言，可以分类为：

　　　　· 无依赖，代表没有发生任何联系，所以二者相互独立，互不影响，没有耦合关系。

　　　　· **单向依赖，**关系双方的依赖是单向的，代表了影响的方向也是单向的，*其中一个实体发生改变，会对另外的实体产生影响，反之则不然，耦合度不高。*

　　　　· **双向依赖，关系双方的依赖是相互的，**影响也是相互的，耦合度较高。

*低耦合，高内聚*

　　低耦合，代表了实现最简单的依赖关系，尽可能地减少类与类、模块与模块、层次与层次、系统与系统之间的联系。低耦合，体现了人类追求简单操作的理想状态，按照软件开发的基本实现技巧来追求软件实体之间的关系简单化，正是**大部分设计模式力图追求的目标；低耦合，降低了一个类或一个模块发生修改对其他类或模块造成的影响，将影响范围简单化。**在本文阐释的依赖关系方式中，*实现单向的依赖，实现抽象的耦合，都是实现"低耦合"的基础条件。*

　　**高内聚，**一方面代表了职责的统一管理，一方面体现了关系的有效隔离。例如单一职责原则其实归根结底是对功能性的一种指导性体现，*将功能紧密联系的职责, 封装为一个类（或模块）*，而判断的准则正是基于引起类变化的原因。所以，封装离不开依赖，而抽象离不开变化，二者的概念和本质都是相对而言的。因此，高内聚的目标体现了以隔离为目标进行统一管理的思想。

　　为了达到低耦合、高内聚的目标，通常意义上的**设计原则和设计模式其实都是朝着这个方向实现的：**

　　　　· *尽可能实现单项依赖。*

　　　　· *不需要进行数据交换的双方，不要实现多此一举的关联，人们将此形象称为“不要向陌生人说话（Don't talk to strangers）”。*

　　　　· **保持内部的封装性，关联的双方不要深入实现细节进行通信，**这是保证高内聚的必需条件。

'''


.标题
====
例如：
下面的代码, 耦合性就很强:

[,subs=+quotes]
----
namespace ConsoleApp4 {

    //引擎类
    *class Cls引擎 {*
        public int Num发动机转速 { get; private set; }
        public void fn发动机启动(int num油门大小) {
            this.Num发动机转速 = 1000 * num油门大小;
        }
    }


    //汽车类
    *class Cls汽车 {*
        private *Cls引擎 ins引擎;  //这里, 两个类就产生了耦合*
        public int Num速度 { get; private set; } //这个字段不需要在实例化本类时赋值, 而是会在下面的"fn汽车启动()"方法中, 才给它赋值.

        //构造函数
        public Cls汽车(Cls引擎 ins引擎) {
            this.ins引擎 = ins引擎;
        }

        public void fn汽车启动(int num油门大小) {
            ins引擎.fn发动机启动(num油门大小);
            this.Num速度 = ins引擎.Num发动机转速 / 100;
        }
    }



    //主函数
    internal class Program {
        static void Main(string[] args) {

            Cls引擎 ins引擎 = new Cls引擎();
            Cls汽车 ins汽车 = new Cls汽车(ins引擎);

            ins汽车.fn汽车启动(num油门大小: 3);
            Console.WriteLine(ins汽车.Num速度); //30

        }
    }
}
----

image:img/0164.svg[,]

====


依赖反转:  A类依赖B类, 就是"依赖";   A类实现了"x接口", 就是"依赖的反转". 即A类向上依赖x接口.

image:img/0165.png[,]

'''

== 单元测试



'''

== 接口隔离原则(ISP)


接口隔离原则(ISP)
设计应用程序的时候，如果一个模块包含多个子模块，那么我们应该小心对模块做出抽象。设想该模块由一个类实现，我们可以把系统抽象成一个接口。但是要添加一个新的模块扩展程序时，如果要添加的模块只包含原系统中的一些子模块，那么系统就会强迫我们实现接口中的所有方法，并且清寒要编写一些哑方法。这样的接口被称为胖接口或者被污染的接口，使用这样的接口将会给系统引入一些不当的行为，这些不当的行为可能导致不正确的结果，也可能导入资源浪费。

1.接口隔离
接口隔离原则（Interface Segregation Principle, ISP）表明客户端不应该被强迫实现一些他们不会使用的接口，应该把胖接口中的方法分组，然后用多个接口替代它，每个接口服务于一个子模块。简单地说，就是使用多个专门的接口比使用单个接口要好很多。

ISP 的主要观点如下：

1）一个类对另外一个类的依赖性应当是建立在最小的接口上的。

ISP 可以达到不强迫客户（接口的使用方法）依赖于他们不用的方法，接口的实现类应该只呈现为单一职责的角色（遵循 SRP 原则） ISP 还可以降低客户之间的相互影响---当某个客户要求提供新的职责（需要变化）而迫使接口发生改变时，影响到其他客户程序的可能性最小。

2）客户端程序不应该依赖它不需要的接口方法（功能）。

客户端程序就应该依赖于它不需要的接口方法（功能），那依赖于什么？依赖它所需要的接口。客户端需要什么接口就是提供什么接口，把不需要的接口剔除，这就要求对接口进行细化，保证其纯洁性。

比如在继承时，由于子类将继承父类中的所有可用方法；而父类中的某些方法，在子类中可能并不需要。例如，普通员工和经理都继承自雇员这个接口，员工需要每天写工作日志，而经理不需要。因此不能用工作日志来卡经理，也就是经理不应该依赖于提交工作日志这个方法。

可以看出，ISP和SRP在概念上是有一定交叉的。事实上，很多设计模式在概念上都有交叉，甚至你很难判断一段代码属于哪一种设计模式。

ISP强调的是接口对客户端的承诺越少越好，并且要做到专一。当某个客户程序的要求发生变化，而迫使接口发生改变时，影响到其他客户程序的可能性小。这实际上就是接口污染的问题。

2.对接口的污染
过于臃肿的接口设计是对接口的污染。所谓的接口污染就是为接口添加不必要的职责，如果开发人员在接口中增加一个新功能的目的只是减少接口实现类的数目，则此设计将导致接口被不断地“污染”并“变胖”。

“接口隔离”其实就是定制化服务设计的原则。使用接口的多重继承实现对不同的接口的组合，从而对外提供组合功能---达到“按需提供服务”。 接口即要拆，但也不能拆得太细，这就得有个标准，这就是高内聚。接口应该具备一些基本的功能，能独一完成一个基本的任务。

在实际应用中，会遇到如下问题：比如，我需要一个能适配多种类型数据库的 DAO 实现，那么首先应实现一个数据库操作的接口，其中规定一些数据库操作的基本方法，比如连接数据库、增删改查、关闭数据库等。这是一个最少功能的接口。对于一些 MySQL 中特有的而其他数据库里并不存在的或性质不同的方法，如 PHP 里可能用到的 MySQL 的 pconnect 方法，其他数据库里并不存在和这个方法相同的概念，这个方法也就不应该出现在这个基本的接口里，那这个基本的接口应该有哪些基本的方法呢？PDO已经告诉你了。

PDO 是一个抽象的数据库接口层，它告诉我们一个基本的数据库操作接口应该实现哪些基本的方法。接口是一个高层次的抽象，所以接口里的方法都应该是通用的、基本的、不易变化的。

还有一个问题，那些特有的方法应该怎么实现？根据ISP原则，这些方法可以在别一个接口中存在，让这个“异类”同时实现这两个接口。

对于接口的污染，可以考虑这两条处理方式：

利用委托分离接口。
利用多继承分离接口。
委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理，如策略模式、代理模式等中都应用到了委托的概念。




在组件构建过程中，某些接口之间直接的依赖,常常会带来很多问题、甚至根本无法实现。*采用添加一层间接（稳定）接口，来"隔离"本来互相紧密关联的接口, 是一种常见的解决方案。*

典型模式
Facade 【注：解决系统内和系统外】
....
fa·çade n.   /fəˈsɑːd/
1.
the front of a building （建筑物的）正面，立面
2.
[ usually sing.] the way that sb/sth appears to be, which is different from the way sb/sth really is （虚假的）表面，外表

•
She managed to maintain a façade of indifference. 她设法继续装作漠不关心的样子。

•
Squalor and poverty lay behind the city's glittering façade. 表面的繁华掩盖了这座城市的肮脏和贫穷。

-> 来自face, 脸。
....

Proxy 【注：两个对象，由于安全/分布式/性能的原因不能直接依赖，必须隔离】
Adapter 【注：解决老接口和新接口的不匹配问题】
Mediator 【注：解耦系统内对象间的关联关系】

image:img/0173.png[,]

**上述 A 方案的问题在于: 组件的客户, 和组件中各种复杂的子系统, 有了过多的耦合，**随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。

如何简化外部客户系统和系统间的交互接口？如何将外部客户程序的演化和内部子系统的变化之间的依赖相互解耦？

为子系统中的一组接口, 提供一个一致（稳定）的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用（复用）。——《设计模式》 GoF

image:img/0174.png[,]


【注】：

Facade （稳定）
其他的可能会变化
8.1.5 要点总结
从客户程序的角度来看，*Facade模式简化了整个组件系统的接口，对于组件内部与外部客户程序来说，达到了一种“解耦”的效果——内部子系统的任何变化不会影响到Facade接口的变化。*
Facade设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。*Facade很多时候更是一种架构设计模式。*
Facade设计模式并非一个集装箱，可以任意地放进任何多个对象。Facade模式中组件的内部应该是“相互耦合关系比较大的一系列组件”，而不是一个简单的功能集合。


[,subs=+quotes]
----
interface Itf坦克类接口 : Itf车类接口, Itf武器类接口 *//接口, 可以继承自多个接口*
----






