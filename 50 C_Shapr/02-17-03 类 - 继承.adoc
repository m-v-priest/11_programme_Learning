
= 类的继承
:sectnums:
:toclevels: 3
:toc: left

---


== 类的继承 (父类, 子类)

我们先写一个父类, 然后写两个子类, 继承自该父类.  然后在其中第二个子类中, 我们重写(覆盖掉)父类的一个方法.

最终的文件结构会如下:

image:img/0022.png[,]


.标题
====
例如： +
父类的文件: +
[source, java]
----
internal class ClsFather
{
    private string name;
    private int age;

    public void fnCan1()
    {
        Console.WriteLine("会爬");
    }

    public void fnCan2()
    {
        Console.WriteLine("会游");
    }
}

----


子类1 (ClsSon1)的文件 :
[source, java]
----
internal class ClsSon1 : ClsFather // 在子类后面, 写冒号, 和父类名称. 这样子类就继承了父类
{

}
----



子类2 (ClsSon1)的文件 :
[source, java]
----
internal class ClsSon2: ClsFather
{
    public string language; //添加一个子类2自己的数据

    public void fnCan2() //重写继承自父类的 fnCan2方法. 会覆盖掉父类的同名方法.
    {
        Console.WriteLine("会走(子类2专属)");
    }
}
----

然后在主文件中: +
[source, java]
----
static void Main(string[] args)
{
 ClsFather insFather  = new ClsFather(); //创建一个父类的实例对象
    insFather.fnCan1(); //会爬
    insFather.fnCan2(); //会游

    ClsSon1 insSon1 = new ClsSon1(); //创建一个"子类1"的对象.
    insSon1.fnCan1(); //会爬  ← 子类能调用"其继承的父类"中的方法
    insSon1.fnCan2(); //会游

    ClsSon2 insSon2 = new ClsSon2();
    insSon2.fnCan2(); //会走(子类2专属) ←由于在 ClsSon2 这个子类中, 我们覆盖了父类的同名方法, 所以这里, 就能直接子类2自己的该方法了.
}
----
====



.标题
====
例如：

本例的类图如下:

image:img/0023.png[,]


父类页面: +
[source, java]
----
internal class ClsPerson
{
    protected string name; //protected权限, 依然是私有的, 但能开放给子类访问.
    protected int age;

    //构造函数 ← 注意!! 父类中, 不需要写构造函数! 否则, 子类的构造函数中, 没法融入从父类继承来的变量数据, 会报错.  所以下面注释掉的代码都不需要写!
    //public ClsPerson(string name, int age)
    //{
    //    this.name = name;
    //    this.age = age;
    //}

    public void fnInfo()
    {
        Console.WriteLine("name: {0}, age:{1}",name,age);
    }

}
----

子类1的页面: +
[source, java]
----
internal class Cls内朝职务: ClsPerson //继承自父类 ClsPerson
{
    public int ab政治学能力;

    //构造函数
    public Cls内朝职务(string name, int age,int ab政治学能力) //这里, 除了在子类中定义的新添加的数据变量外, 还要把从父类中继承过来的数据变量, 也要写在这里. 进行赋值.
    {
        this.ab政治学能力 = ab政治学能力;
        this.name = name;
        this.age = age;
    }


    public void fn参论机要()
    {
        Console.WriteLine("{0} 参论机要. 政治能力是{1}", this.name, this.ab政治学能力);
    }
}
----


子类2的页面: +
[source, java]
----
internal class Cls外朝职务: ClsPerson  //继承自父类 ClsPerson
{
    protected int ab经济学能力;

    //构造函数
    public Cls外朝职务(string name, int age,int ab经济学能力) //别忘了, 在子类的构造方法中, 要把从父类继承来的数据, 也一起带进来赋值
    {
        this.ab经济学能力 = ab经济学能力;
        this.name = name;
        this.age = age;
    }

    public void fn开发经济()
    {
        Console.WriteLine("{0} 开发经济...  经济能力是{1}",this.name, this.ab经济学能力);
    }
}
----


主页面 +
[source, java]
----
static void Main(string[] args)
{
    Cls内朝职务 ins內朝官 = new Cls内朝职务("zrx", 16,99);
    ins內朝官.fnInfo(); //name: zrx, age:16
    ins內朝官.fn参论机要(); //zrx 参论机要. 政治能力是99

    Cls外朝职务 ins外朝官 = new Cls外朝职务("诸葛亮", 27, 98);
    ins外朝官.fn开发经济(); //诸葛亮 开发经济...  经济能力是98
}
----


====


---

== 子类的构造函数, 继承父类的构造函数

image:img/0025.png[,]

.标题
====
例如：

父类页面: +
[source, java]
----
internal class ClsFather
{
    protected string name;
    protected int money;

    //构造函数
    public ClsFather(string name, int money)
    {
        this.name = name;
        this.money = money;
    }

    public void fnGetMoney()
    {
        Console.WriteLine(this.money);
    }
}
----

子类页面: +
[source, java]
----
internal class ClsSon1 : ClsFather
{
    protected int money;  //这里子类覆盖了父类中同名的money数据

    public ClsSon1(int moneySon, string nameFahter, int moneyFather) : base(nameFahter, moneyFather)  //注意: 父类中有一个有参构造函数. 所以你子类定义构造函数时,必须把父类的构造函数中的数据也带进来赋值. 相当于"子类的构造函数"继承了"父类的构造函数", 所以要在子类构造函数后面, 加上 ":base(父类构造函数中的参数)"这个语句.  如果你父类的构造函数是无参的, 才不需要在这里传递父类的参数.
    {
        this.money = moneySon;
        base.money = moneyFather;  //base 就指代"父类", 这里, 我们在子类里面, 即在子类实例化时, 传参时, 可以连带给父类的实例中的数据来赋值,
        base.name = nameFahter;
    }

    public void fnGetMoney()
    {
        Console.WriteLine("儿子的钱是{0}, 父亲{1}的钱是{2}", this.money, base.name, base.money);
    }
}
----

image:img/0024.png[,]

主页面: +
[source, java]
----
static void Main(string[] args)
{
    ClsFather insFather = new ClsFather("zrx", 3000);
    insFather.fnGetMoney(); //3000

    ClsSon1 insSon1 = new ClsSon1(800, "zrx", 3000); //因为我们在ClsSon1子类的构造函数里, 规定要传入三个参数: 儿子的钱, 父亲的名字,父亲的钱
    insSon1.fnGetMoney(); //儿子的钱是800, 父亲zrx的钱是3000
}
----
====

一般, 我们不会在子类中, 去覆盖父类中的同名数据, 只会去覆盖同名方法(函数). 比如, 同样是 "fn_工作()", 子类的工作生态, 可能和父类的工作生态不一致. 所以可以在子类中, 重写父类的同名方法.


'''

== 里式转换 -> 1."父类变量", 可以指向"子类的实例". 但无法记得子类中的函数方法. 2.但你可以将"父类变量", 强制类型转换为"子类类型"后, 父类变量, 就既能记得父类中的函数方法, 也能记得子类中的函数方法了.

1、里氏转换
     1)、子类可以赋值给父类
     2)、如果父类中装的是子类对象，那么可以讲这个父类强转为子类对象。

2、子类对象可以调用父类中的成员，但是父类对象永远都只能调用自己的成员。

3、

- is：表示类型转换，如果能够转换成功，则返回一个true，否则返回一个false
- as：表示类型转换，如果能够转换则返回对应的对象，否则返回一个null


[,subs=+quotes]
----

namespace ConsoleApp1
{

    public class ClsFather {
        public  void fnFatherPrint() {
            Console.WriteLine("我是父类");
        }
    }


    public class ClsSon:ClsFather { //子类继承子父类
        public  void fnSonPrint() {
            Console.WriteLine("我是子类-男");
        }
    }


    public class ClsDaughter : ClsFather { //子类继承子父类
        public  void fnDaughterPrint() {
            Console.WriteLine("我是子类-女");
        }
    }





    internal class Program
    {
        static void Main(string[] args)
        {

            ClsSon insSon = new ClsSon();
            insSon.fnSonPrint(); //我是子类-男
            insSon.fnFatherPrint(); //我是父类 ←子类可以调用"从父类上继承来的方法".


            ClsFather  insFather =new ClsFather();
            //insFather.fnSonPrint();  //报错. ← 但父类实例, 无法调用只属于子类的方法.


            *//1.子类可以赋值给父类. 即, 父类实例的变量, 可以指针指向子类实例.*
            insFather = insSon; //这有什么用处呢? 比如, 如果一个地方, 需要使用父类来作为参数, 则我们可以用一个子类来代替它. (可以木兰替父从军)

            ClsFather insFather2 = new ClsSon(); //上面一句的代码就相当于这句. "父类实例"的变量,可以指向"子类实例".
            insFather2.fnFatherPrint();  *//但是, 父类变量, 依然不会忘记自己的本源出处, 即脑袋里只会记得父类中的方法, 而不会记得子类中的方法. 即, 它访问不到子类中的方法.*
                                         // insFather2.fnSonPrint(); //报错.


            *//2.如果父类变量中, 指向的是子类实例, 那么我们就可以将这个父类变量, 强制转换为"子类类型"的实例对象.*
            ClsSon  insFather2toSon = (ClsSon)insFather2; *//将指向子类的"父类变量", 强制类型转换为子类类型.*
            insFather2toSon.fnSonPrint(); *//然后, 该父类变量, 就能记得子类中的方法了.*
            insFather2toSon.fnFatherPrint(); *//同时, 该父类变量, 也不会忘记父类中的方法. 即, 现在它拥有了双重记忆, 一个是父类中的记忆, 一个是子类中的记忆.*

        }
    }
}
----


'''

==== 转换类型前, 先用 is 判断 "变量a, 与B类型, 是否相符?". 类型相符, 才能将a变量 转成 B类型.

其实, 将父类变量, 强制类型转换成某个子类类型之前, 我们应该先做一个类型判断:

is判断一个对象是否兼容于指定的类型，才考虑里氏代换。

[,subs=+quotes]
----
ClsFather ins父类实例 = new ClsFather();
ClsSon ins子类男实例= new ClsSon();
ClsDaughter ins子类女实例 = new ClsDaughter();


ins父类实例 = ins子类男实例;

*//下面的判断, 能成功, 因为上面一行代码, 我们的确是将父类变量, 指向子类类型的. 即父类变量, 的确是属于子类类型.*
*if(ins父类实例 is ClsSon) { //is运算符, 用来判断对象是不是某种类型. 比如, x is double*
    ClsSon ins父类实例转子类类型 = (ClsSon)ins父类实例;
    ins父类实例转子类类型.fnSonPrint();
}
else {
    Console.WriteLine("a变量不属于B类型, 所以无法将a变量\"强制类型转换\"成B类型");
}


*//下面的判断, 会判定为类型不符. 因为父类变量, 并不指向"子类女"的类型. 所以就无法强制类型转换成"子类女"的类型.*
if (ins父类实例 is ClsDaughter) { //is运算符, 用来判断对象是不是某种类型. 比如, x is double
    ClsDaughter ins父类实例转子类女类型 = (ClsDaughter)ins父类实例;
}
else {
    Console.WriteLine("a变量不属于B类型, 所以无法将a变量\"强制类型转换\"成B类型");
}
----

'''

==== 也可以用 as, 来做类型转换. a变量, 与B类型相符, 则能转换成功.  如果a变量, 与B类型不相符, 则 as 会返回一个 null.

as 与强制类型转换一样，区别是使用as是安全的。使用as如果转换失败，返回Null，不会抛出异常。

[,subs=+quotes]
----
ClsFather ins父类实例 = new ClsFather();
ClsSon ins子类男实例= new ClsSon();
ClsDaughter ins子类女实例 = new ClsDaughter();


*ClsSon ins父类变量转男子类 = ins父类实例 as ClsSon; //"父类变量", 强制类型转成"子类类型". 即, as的用法, 如果转换成功, 则就把转换后的实例返回给你. 如果转换失败, 则返回null.*
ins父类变量转男子类.fnSonPrint(); //ok
ins父类变量转男子类.fnFatherPrint();  //ok


ClsFather ins父类实例2 = new ClsSon(); //父类变量,指向子类男实例
ClsDaughter ins父类变量转女子类 = ins父类实例2 as ClsDaughter;  /*/这里, 会转换失败, 返回null. 因为上面我们将父类变量, 指向了"子类男", 显然就不能再将父类变量, 转成"子类女"了*
ins父类变量转女子类.fnDaughterPrint(); //报错.提示: ins父类变量转男子类 是 null.
----





强制类型转换，有可能会导致异常。is与as就是为了解决这一问题，is与as永远不会抛出异常。

使用is和as可以取代强制类型转换，分别如下：　

使用is
[,subs=+quotes]
----
if(a is Dog)
{
　　Dog d = (Dog)a;
　　...
}
----

使用as
[,subs=+quotes]
----
Dog d = a as Dog;
if(d!=null)
{
    ...
}
----

注意：二者效果一样，但是效率差别很大，**使用is会检查两次对象的类型，一次是核实，一次是强制转换。使用as只进行了一次对象类型的检查。**检查对象的类型，是个耗费资源的操作，首先要判断对象的实际类型，然后必须遍历继承树结构（层次结构），去与每个基类核对。



'''

== 查看类图 (类的继承关系图)

先在 visual studio 的菜单:  工具 -> 获取工具和功能

image:img/0015.png[,]

安装 "扩展开发"

image:img/0016.png[,]

然后, 在"单个组件"中, 搜索"类", 勾选"类设计器".

image:img/0017.png[,]

然后, 点整个界面右下角的"修改" (相当于是安装功能)

选菜单: 视图 -> 类视图

image:img/0018.png[,]

image:img/0019.png[,]

image:img/0020.png[,]

image:img/0021.png[,]


---
