
= 密封类
:sectnums:
:toclevels: 3
:toc: left

---

== 密封类, 相当于被"阉割"的类, 它生不出后代(没有子类)

如果所有的类都可以被继承，那么很容易导致继承的滥用. 为了避免滥用继承，C#中提出了密封类的概念。

- *密封类可以用来限制扩展性，如果密封了某个类，则其他类不能从该类继承；*
- *如果密封了某个成员，则派生类不能重写该成员的实现.*
-** 密封类不能作为基类被继承，但它可以继承别的类或接口。**
- *由于密封类的不可继承性，因此密封类不能声明为抽象的*，即sealed修饰符, 不能与abstract修饰符同时使用。

*一句话, 如果你不希望自己编写的类被继承；或, 你的类没有必要再被继承，你就可以用sealed 将你的类设为"密封类", 来达到"该类不能再派生其它类"的目的.*

"密封类"不能同时又是"抽象类"，因为"密封类"不能用作基类、也不能被继承，而"抽象类"总是希望被继承的。



如果类满足如下条件，则应将其密封:

- 类是静态类。
- 类中包含带有安全敏感信息的受保护成员。

[,subs=+quotes]
----
namespace ConsoleApp4 {

    //父类
    internal *sealed* class Cls密封类 { *//密封类, 相当于把该类阉割了, 它无法再被继承. 没有子类.*
        public void fnTalk() {
            Console.WriteLine("我是密封类");
        }
    }


    //主函数
    internal class Program {
        static void Main(string[] args) {
            *Cls密封类 ins密封类 = new Cls密封类(); //密封类自己可以实例化. 但它没有后代.*
            ins密封类.fnTalk(); //Console.WriteLine("我是密封类");
        }
    }
}
----

'''

== 父类中, 方法前加上 sealed 关键字后, 该方法就不能再被子类 Override 重写了.

也可以在类中, 使用sealed修饰符, 来密封整个类，这会隐式地密封类中所有的虚函数。把类密封, 比把函数密封, 更常见。

*虽然"密封"可以防止 override 重写,但是它却无法阻止成员被 new 隐藏。*

'''








