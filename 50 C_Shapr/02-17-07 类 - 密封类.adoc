
= 密封类
:sectnums:
:toclevels: 3
:toc: left

---


== 密封类

如果所有的类都可以被继承，那么很容易导致继承的滥用. 为了避免滥用继承，C#中提出了密封类的概念。

- 密封类可以用来限制扩展性，如果密封了某个类，则其他类不能从该类继承；
- 如果密封了某个成员，则派生类不能重写该成员的实现.
- 密封类不能作为基类被继承，但它可以继承别的类或接口。
- 由于密封类的不可继承性，因此密封类不能声明为抽象的，即sealed修饰符, 不能与abstract修饰符同时使用。


如果类满足如下条件，则应将其密封:

- 类是静态类。
- 类中包含带有安全敏感信息的受保护成员。

.标题
====
创建密封类
[source, java]
----
sealed internal class ClsSeal //密封类, 用sealed关键词声明. 密封类, 无法被继承. 它没有子类.
{

}
----
====



.标题
====
创建密封方法.

父类是: +
[source, java]
----
internal class ClsFather
{
    public virtual void fn秘密() //用 virtual 把它表示为虚方法, 它才能有继承关系, 即有子类能继承它.
    { Console.WriteLine("老爸的秘密"); }
}
----

子类是: +
[source, java]
----
internal class ClsSon:ClsFather //继承自父类
{
    public sealed override void fn秘密() //重写父类的同名方法. 并设置为 sealed 密封. 即它不能再被其自己的子类(相当于孙类)重写了. 即,  我们可以将类或方法, 设为 sealed ,以防止它们被后代重写.  另外, 当sealed用于方法或属性时，必须始终与override一起使用。

    { Console.WriteLine("儿子的秘密"); }
}
----


====



---
