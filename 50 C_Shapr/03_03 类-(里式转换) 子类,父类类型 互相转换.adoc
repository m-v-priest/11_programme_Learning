
= 类的继承
:sectnums:
:toclevels: 3
:toc: left

---

== 里式转换

==== (1)"父类变量", 可以指向"子类的实例". 但无法记得子类中的函数方法. (2)但你可以将"父类变量", 强制类型转换为"子类类型"后, 父类变量, 就既能记得父类中的函数方法, 也能记得子类中的函数方法了.

即, 子类对象可以调用父类中的成员，但是父类对象, 永远都只能调用(记得)自己(父类中的)的成员。



[,subs=+quotes]
----
namespace ConsoleApp1
{
    //父类
    public class ClsFather {
        public  void fnFatherPrint() {
            Console.WriteLine("我是父类");
        }
    }


    //子类1
    public class ClsSon:ClsFather { //子类继承子父类
        public  void fnSonPrint() {
            Console.WriteLine("我是子类-男");
        }
    }


    //子类2
    public class ClsDaughter : ClsFather { //子类继承子父类
        public  void fnDaughterPrint() {
            Console.WriteLine("我是子类-女");
        }
    }


    //主文件中
    internal class Program
    {
        static void Main(string[] args)
        {

            ClsSon insSon = new ClsSon();
            insSon.fnSonPrint(); //我是子类-男
            *insSon.fnFatherPrint(); //我是父类 ←子类可以调用"从父类上继承来的方法".*


            ClsFather  insFather =new ClsFather();
           ** //insFather.fnSonPrint();  //报错. ← 但父类实例, 无法调用只属于子类的方法.**


            *//1.子类可以赋值给父类. 即, 父类实例的变量, 可以指针指向子类实例.*
            insFather = insSon; //这有什么用处呢? *比如, 如果一个地方, 需要使用父类来作为参数, 则我们可以用一个子类来代替它. (可以木兰替父从军)*

            ClsFather insFather2 = new ClsSon(); //上面一句的代码就相当于这句. "父类实例"的变量,可以指向"子类实例".
            insFather2.fnFatherPrint();  *//但是, 父类变量, 依然不会忘记自己的本源出处, 即脑袋里只会记得父类中的方法, 而不会记得子类中的方法. 即, 它访问不到子类中的方法.*
                                         // insFather2.fnSonPrint(); //报错.


            *//2.如果父类变量中, 指向的是子类实例, 那么我们就可以将这个父类变量, 强制转换为"子类类型"的实例对象.*
            ClsSon  insFather2toSon = (ClsSon)insFather2; *//将指向子类的"父类变量", 强制类型转换为子类类型.*
            insFather2toSon.fnSonPrint(); *//然后, 该父类变量, 就能记得子类中的方法了.*
            insFather2toSon.fnFatherPrint(); *//同时, 该父类变量, 也不会忘记父类中的方法. 即, 现在它拥有了双重记忆, 一个是父类中的记忆, 一个是子类中的记忆.*

        }
    }
}
----

但, 上面我们都是用的"强制类型转换"，这有可能会导致异常。 为了解决这一问题, C# 就提供了 is 与 as 的语法来帮你转换，is与as永远不会抛出异常.

使用is和as, 可以取代你手动的"强制类型转换".


使用is: 
[,subs=+quotes]
----
if(a is Dog)  //is 会返回 ture 或 false
{
    Dog d = (Dog)a;
    ...
}
----


使用as
[,subs=+quotes]
----
Dog d = a as Dog;  //as会返回 转换后的对象 或 null
if(d!=null)
{
    ...
}
----


'''

== 将父类变量, 转成"子类类型"

将父类变量, 转成"子类类型"之前, 要先做类型判断.

==== is -> ins父类实例 is Cls子类类型 ← is 如果能够转换成功，则返回一个true; 否则返回一个false

[,subs=+quotes]
----
ClsFather ins父类实例 = new ClsFather();
ClsSon ins子类男实例= new ClsSon();
ClsDaughter ins子类女实例 = new ClsDaughter();


ins父类实例 = ins子类男实例;

*//下面的判断, 能成功, 因为上面一行代码, 我们的确是将父类变量, 指向子类类型的. 即父类变量, 的确是属于子类类型.*
*if(ins父类实例 is ClsSon) { //is运算符, 用来判断对象是不是某种类型. 比如, x is double*
    ClsSon ins父类实例转子类类型 = (ClsSon)ins父类实例;
    ins父类实例转子类类型.fnSonPrint();
}
else {
    Console.WriteLine("a变量不属于B类型, 所以无法将a变量\"强制类型转换\"成B类型");
}


*//下面的判断, 会判定为类型不符. 因为父类变量, 并不指向"子类女"的类型. 所以就无法强制类型转换成"子类女"的类型.*
if (ins父类实例 is ClsDaughter) { //is运算符, 用来判断对象是不是某种类型. 比如, x is double
    ClsDaughter ins父类实例转子类女类型 = (ClsDaughter)ins父类实例;
}
else {
    Console.WriteLine("a变量不属于B类型, 所以无法将a变量\"强制类型转换\"成B类型");
}
----



'''

==== as -> ins父类实例 as Cls子类类型  ← as如果转换成功, 则返回对应的对象; 否则，返回 Null.


[,subs=+quotes]
----
ClsFather ins父类实例 = new ClsFather();
ClsSon ins子类男实例= new ClsSon();
ClsDaughter ins子类女实例 = new ClsDaughter();


*ClsSon ins父类变量转男子类 = ins父类实例 as ClsSon; //"父类变量", 强制类型转成"子类类型". 即, as的用法, 如果转换成功, 则就把转换后的实例返回给你. 如果转换失败, 则返回null.*
ins父类变量转男子类.fnSonPrint(); //ok
ins父类变量转男子类.fnFatherPrint();  //ok


ClsFather ins父类实例2 = new ClsSon(); //父类变量,指向子类男实例
ClsDaughter ins父类变量转女子类 = ins父类实例2 as ClsDaughter;  /*/这里, 会转换失败, 返回null. 因为上面我们将父类变量, 指向了"子类男", 显然就不能再将父类变量, 转成"子类女"了*
ins父类变量转女子类.fnDaughterPrint(); //报错.提示: ins父类变量转男子类 是 null.
----

'''

== 子类变量, 指向父类实例 -> 要先将父类实例, 转成"子类类型"后,  子类变量才能指向该父类实例.

子类变量insSon, 不能指向父类实例insFather. 但我们可以通过强制类型转换, 来讲父类实例insFather, 转成属于子类类型的 (ClsSon)insFather, 于是, 这个子类变量insSon, 就能指向这个实例了 insSon = (ClsSon)insFather.

[,subs=+quotes]
----
static void Main(string[] args)
{

    ClsFather insFather;
    ClsSon insSon;

    insFather = new ClsSon(); //父类变量, 指向子类的实例
    insFather.fnFather(); //from fahter  ← 即使父类变量, 指向子类实例, 它也不会忘记自己是属于父类的, 只会访问到父类中的方法, 而不能访问到子类中的方法.

    // insSon =new ClsFather();  //这句会报错, 因为子类变量, 不能指向父类实例.

    *insSon = (ClsSon)insFather; // 但你可以用强制类型转换, 把父类实例, 转成子类类型, 这样,  子类变量 insSon 就能指向该实例对象(insFather)了.   这样后, 该子类变量, 既记得自己属于子类, 也记得自己属于父类. 于是就,  既可以调用子类中的方法, 也可以调用父类中的方法*
    insSon.fnFather(); //from fahter
    insSon.fnSon(); //from son

    //上面的强制类型转换, 还可以写成更简单的形式:
    *insSon = insFather as ClsSon;*  // 这句的意思就相当于 insSon = (ClsSon)insFather;  即: insSon这个变量, 会指针指向 "被强制类型转换成子类ClsSon类型"的父类实例 insFather.
    insSon.fnFather(); //from fahter
    insSon.fnSon(); //from son
}
----

image:img/0037.svg[,50%]

'''



