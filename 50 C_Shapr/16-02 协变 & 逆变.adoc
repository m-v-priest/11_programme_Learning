
= 协变 & 逆变
:sectnums:
:toclevels: 3
:toc: left

---

只有泛型接口, 和泛型委托参数, 支持协变和逆变.

- 如果某个返回的类型, 可以由其"子类"替换，那么这个类型就是支持"协变"的.
- 如果某个参数类型, 可以由其"父类"替换，那么这个类型就是支持"逆变"的.

协变和逆变, 是针对"泛型接口或泛型委托"参数的,而不能针对"泛型类".

——在泛型中，如果确定泛型参数是只读或者只写的，那么就可以使用协变或者逆变。如果泛型参数无法确定只读或只写，这种类型参数, 既不能协变也不能逆变，只能精确类型匹配.

——*在泛型或委托中，如果不使用协变或逆变，那么泛型类型是一个固定类型，而使用协变或逆变的话，则泛型类型可以实现多态化*

——*协变和逆变, 只针对于"引用类型". 而"值类型"不参与协变和逆变.*

——声明属性时要注意，*只有"只读属性"才允许使用out类型参数，"只写属性"才允许使用in类型参数.*


'''

== 协变

*协变, 在泛型方法的参数里, 以out表示.*  +
使用out, 可以在声明父类泛型参数的时候, 使用子类泛型参数构造. +
out参数只能用在输出位置，作为返回值.

[,subs=+quotes]
----
class Cls父类 {
    public static string name;
}

//子类继承自父类
class Cls子类 : Cls父类 {
}


internal class Program {
    //委托方法, 返回值是T类型的.
    *delegate T fn委托方法<T>();*

    //下面的静态方法, 返回类型是"Cls子类"类型的
    static Cls子类 fn返回子类实例() {
        return new Cls子类();
    }

    //主函数
    static void Main(string[] args) {
        Cls父类 ins父类 = new Cls子类(); //父类变量, 可以指向子类实例.

        *fn委托方法<Cls子类> var指向返回子类实例函数的指针 = fn返回子类实例; //创建一个"委托方法"类型的变量"var函数指针", 指针指向"fn返回子类实例"函数.*

        *//fn委托方法<Cls父类> var函数指针2 = var指向返回子类实例函数的指针; //报错! 虽然父类可以指向子类实例, 但是委托之间,却未存在关联，无法进行强制类型的转换.*
    }
}
----

image:img/0237.png[,]

image:img/0238.svg[,]

要解决上面的问题, 就要引入了"协变"来解决. 只要改动一个地方就行了:

image:img/0239.png[,]

image:img/0240.svg[,]





<c# 7.0 核心技术指南> p 138 继续

'''


== 逆变

*逆变, 在泛型方法的参数里, 以in表示.* +
使用in, 可以在声明子类泛型参数的时候, 使用父类泛型参数构造. +
int参数只能用在输入位置，作为传入值.


'''

https://www.jianshu.com/p/847643a0d16e

什么是协变（covariance）和抗/逆变（contravariance）？

先从字面意思理解一下这两个词：

- co- 在英语中表示“协同”、“合作”的前缀，协变的字面意思就是“与变化的方向相同”。
- contra- 在英语中表示“相反”的前缀，逆变的字面意思就是“与变化方向相反”。

那么问题来了，这里的变化方向是什么东西？请往下看：

子类型 是在编程中的一个棘手的话题，棘手的原因是来自于一对经常被误解的术语，即协变和抗变。这篇文章将来解释它们。

下面我们约定三个规则：

- A ≤ B  表示A是B的子类型
- A → B  表示这是一个参数类型为A, 返回值为B 的方法
- x : A  表示x的类型是A


现在我们有下面三种类型：

二哈 ≤ 狗 ≤ 动物
显然，二哈是狗的子类型，然后狗又是动物的子类型。然后子类型之间的关系通常是可以传递的，所以我们通常说二哈也是动物的一种。

然后问题来了，下面哪种类型是狗 → 狗的子类型？

二哈 → 二哈
二哈 → 动物
动物 → 动物
动物 → 二哈

我们来试着解决这个问题，假设我们有个名为f的方法，它的参数的类型是狗 → 狗。然后返回值我们不用去关心，为了直观一点，我们写出来：

f: (狗 → 狗) → any
现在我们用g作为参数来调用 f。来看看上面的几种类型分别会发生什么。

g: 二哈 → 二哈，作为 f(g) 的类型安全吗？
不安全，因为f的参数是一个参数类型狗的方法，所以可能会传入狗的其他子类型例如泰迪，然而泰迪和二哈是不可以兼容的。

g: 二哈 → 动物，作为 f(g) 的类型安全吗？
不安全，原因同上。

g: 动物 → 动物，作为 f(g) 的类型安全吗？
不安全，现在g的参数类型为动物，而f的参数的参数类型为狗，所以传入任何种类的狗，都可以兼容当前的g的参数类型动物，因为狗 ≤ 动物。但是因为f中的参数返回的是狗，例如狗都有吠方法。但是此时的g的返回值动物却不一定都有吠方法。

g: 动物 → 二哈，作为 f(g) 的类型安全吗？
安全，首先f的参数中的参数类型为狗，而任意的狗都属于动物，所以没有问题，另外f的参数中的返回值为狗，而g的返回值为二哈。但是因为二哈是狗的子类型，所以狗可以做的事情，二哈一定可以做到。

小结
因此，下面这样是安全的：

(动物 → 二哈) ≤ (狗 → 狗)
返回类型很直接了当，二哈是狗的子类型。但是参数类型刚好反转了，动物是狗的父类型。

用术语来描述这个奇怪的行为就是，我们允许函数类型在其返回类型中是协变的，在其参数类型中是抗变的。返回类型允许协变意味着如果 A ≤ B，那么意味着(T → A) ≤ (T → B)，A永远在≤的左边，B永远在≤的右边。同理，参数类型的抗变意味着如果 A ≤ B，那么(B → T) ≤ (A → T)，A和B完全反转了。

Extra：在 TypeScript 中，参数类型是双变的（即可以协变，亦可以抗变），这实际上是不安全的做法（在 TypeScript 2.6 中，你可以通过 --strictFunctionTypes或者--strict来修复这个问题）。

如果是其他类型呢？
问题：List<狗>是List<动物>的子类型吗？

答案有点微妙。如果列表是不可变的，那么可以肯定的说是的，但是如果列表是可变的，那么肯定不是。

为什么？假设我需要一个List<动物>，你传给我一个List<狗>。因为我认为我有一个List<动物>，我可能会尝试插入猫进去，现在你的List<狗>里面有一只猫了，系统不应该允许这种类型。

通常我们允许不可变 List 的参数协变，但是如果是可变列表，那么它的参数一定是不可变的。

Extra：在 Java 中，数组都是可变和协变的，当然，这是不安全的。
