
= 字典
:sectnums:
:toclevels: 3
:toc: left
''''



== Dictionary 字典


== Dictionary 和 hashTable 的区别

显然, dictionary类型中的元素, 是键值对, key 和 value 没有特定类型, 也是泛型.

Key和Value可以是任何类型（string，int，custom class 等）


C# 中, hashTable 和 Dictionary的区别:

都是使用double hashing实现hash算法。



Dictionary<K,V>

- 键值Key不存在的时候, 会抛出异常。
- 对于值类型没有boxing，unboxing所以效率高于hashtable
- dictionary中只有public static的方法是线程安全的。
- dictionary是泛型类



Hashtable

- 当key不存在时, 返回null
- *对于值类型的存取效率, 低于dictionary*
- 所有成员变量时线程安全的。
- 泛型类


HashTable和Dictionary都是用于存储数据的数据结构的类型。这两个数据结构都将存储的数据保存为键值对。

根据这些关键特征之间的区别，我们可以区分HashTable和Dictionary，如下所示：


[options="autowidth"]
|===
|序号 |键 |HashTable 哈希表 |Dictionary 字典
|1
|定义
|HashTable是集合的非通用类型，用于在键/值对中存储数据，并在System.Collections命名空间中定义。
|另一方面，Dictionary是在System.Collection.Generics命名空间下定义的通用类型集合，该命名空间还以键/值对的形式存储数据。

|2
|数据类型
|在HashTable中，可以将相同或不同的数据类型数据存储为键和值，没有限制，键和值必须具有相同的DataType，然后只能存储在HashTable中。同样，也**无需指定键和值的类型。**
|另一方面，如果Dictionary的键和值必须具有相同的DataType，则只能将其存储在Dictionary中，并且**必须在创建时指定键和值的类型。**

|3
|数据检索
|在HashTable的情况下，由于装箱和拆箱，*数据检索比Dictionary中的数据检索要慢。*
|另一方面，在Dictionary数据的情况下，*检索速度更快，因为在Dictionary的情况下不会进行装箱和拆箱。*

|4
|空值
|如果HashTable空值作为访问时的键处理，则**该键在给定的HashTable中不存在，则返回空值作为结果。**
|另一方面，在Dictionary的情况下，*如果尝试访问给定Dictionary中不存在的键，则会出错。*

|5
|数据顺序
|*HashTable不维护插入键值数据的任何顺序。*
|另一方面，*Dictionary保持存储值的插入顺序。*
|===


1、Dictionary是顺序存储，Hashtable则不是。
比较明显的对比就是使用foreach，Dictionary是按照Add的顺序排列的，Hashtable则是无序的。

2、单线程程序中推荐使用 Dictionary, 有泛型优势, 且读取速度较快, 容量利用更充分.

3、在单线程的时候使用Dictionary更好一些，多线程的时候使用
HashTable更好。多线程程序中推荐使用 Hashtable, 默认的 Hashtable 允许单线程写入多线程读取, HashTable可以通过Hashtable tab = Hashtable.Synchronized(new Hashtable());获得线程安全的对象。当然因为各自电脑的情况不一样，可能会有部分误差。而 Dictionary 非线程安全, 必须人为使用 lock 语句进行保护, 效率大减。

我个人是觉得，**无论什么时候，都应该使用Dictionary< K,V >，**理由如下：
1、*Dic是类型安全的，这有助于我们写出更健壮更具可读性的代码，而且省却我们强制转化的麻烦。这个相信大家都明白。*
2、**Dic是泛型的，当K或V是值类型时，其速度远远超过Hashtable。**这个大家对值类型与引用类型有所了解的话也会明白。
3、如果K和V都是引用类型，如eaglet所测，Hashtable比Dic更快，这里我要指出，eaglet所做的测试是有问题的。原因在于Hashtable与Dic采用的是不同的数据结构。eaglet的“Dictionary 由于在Hashtable基础上封装了一层”这个说法是不对的。

具体我也不讲了，因为有人（Angel Lucifer）已经讲得很清楚了，引用如下：

http://www.cnblogs.com/lucifer1982/archive/2008/06/18/1224319.html
http://www.cnblogs.com/lucifer1982/archive/2008/07/03/1234431.html

*我认为应该始终使用Dictionary< K, V >，即使要用Hashtable了，也可以用Dictionary< object, object >来替代。*

'''


== 增 ->  dic我的字典.Add(key, value)

[,subs=+quotes]
----
//创建"字典泛型集合"的实例
*Dictionary<string, string> dic我的字典 = new Dictionary<string, string>();*


//添加元素
*dic我的字典.Add("曹操", "魏王");* //即 key是"曹操", value是"魏王"
dic我的字典.Add("刘备", "汉中王");
dic我的字典.Add("孙权", "吴王");
----



'''

== 删


'''

== 改

'''

== 查

==== 以key取value -> dic我的字典[key]


[,subs=+quotes]
----
//以key取value
Console.WriteLine(*dic我的字典["刘备"]*); //汉中王 ← 输出该key对应的value值
----


'''


== 判断

==== 判断字典中是否存在某key -> dic我的字典.ContainsKey(key)

[,subs=+quotes]
----
//判断字典中是否存在某key
Console.WriteLine(*dic我的字典.ContainsKey("孙权")*); //True
----


'''


==== 判断字典中是否存在某value

[,subs=+quotes]
----
//判断字典中是否存在某value
Console.WriteLine(*dic我的字典.ContainsValue("魏王")*);//True
----


'''


== 遍历

==== 遍历键值对 (简单快捷)

[,subs=+quotes]
----
foreach (var item in dic我的字典) {
    Console.WriteLine("{0},{1}", *item.Key, item.Value*);
}
----

这里的 item 是底层在 MoveNext 的过程中用 KeyValuePair 包装出来的.

'''


==== 遍历元素"键值对" -> foreach (KeyValuePair<key的类型, value的类型> itemKV in dic我的字典) {}

[,subs=+quotes]
----
//遍历元素"键值对". 字典中的元素类型是 KeyValuePair<key的类型, value的类型>
*foreach (KeyValuePair<string,string> itemKV in dic我的字典) {*
    Console.WriteLine("{0},{1}",itemKV.Key,itemKV.Value);
}
----


'''

==== 只遍历 key -> dic我的字典.Keys  ←  返回的集合类型, 是 Dictionary<key的类型, value的类型>.KeyCollection 类型

字典中, 所有key集合的类型, 是 Dictionary<key的类型, value的类型>.KeyCollection

[,subs=+quotes]
----
//只遍历 key.
*Dictionary<string,string>.KeyCollection allKey = dic我的字典.Keys;*

foreach (string key in allKey) {
    Console.WriteLine(key);
}
----

或直接
[,subs=+quotes]
----
*foreach (var itemKey in dic我的字典.Keys)* {
    Console.WriteLine("key={0},value={1}",*itemKey, dic我的字典[itemKey]*);
}
----


'''

==== 只遍历 value. → dic我的字典.Values ← 返回的集合类型, 是 Dictionary<key的类型, value的类型>.ValueCollection 类型

[,subs=+quotes]
----
//只遍历 value.
*Dictionary<string, string>.ValueCollection allValue = dic我的字典.Values;*

foreach (var value in allValue) {
    Console.WriteLine(value);
}
----


'''
