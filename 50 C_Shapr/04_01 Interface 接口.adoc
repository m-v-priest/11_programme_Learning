
= 接口
:sectnums:
:toclevels: 3
:toc: left

---

== 接口 interface

- 接口中, 只包含方法的声明, 而没有方法的实现. 方法的实现是派生类的责任. 换言之, 接口本身并不实现任何功能，它只是提供了派生类应遵循的标准结构 (苹果 Apple MFi 认证).
- 接口不能有"构造函数"，也不能有字段.
- 接口也不允许运算符重载.
- 接口定义中, 不允许声明成员的修饰符，接口成员都是公有的.


'''

== 创建一个接口

image:img/0034.png[,]

image:img/0035.png[,]


[,subs=+quotes]
----
//接口
namespace my03_接口
{
    internal *interface InterfaceFly*
    {
        public void fnFly(); *//在本接口中, 我们声明一个fly飞翔方法, 但没有具体函数体.*
    }
}


//用来实现接口的"类":
internal *class Cls我 : InterfaceFly  // 本类, 将要实现 InterfaceFly接口*
{

    *public void fnFly()  //在本类中, 来具体实现"接口中定义的方法".*
    {
        Console.WriteLine("Cls我, 这个类, 具体实现了 fly 方法");
    }
}
----

'''

==== 引入接口, 就能让类与类之间的耦合, 变松


[,subs=+quotes]
----
namespace ConsoleApp4 {

    //接口
    *interface Itf手机 {*
        void fn拨号();
        void fn上网();
        void fn装app();
    }


    //下面的类, 来实现上面的接口
    *class Cls苹果手机 : Itf手机 {*
        public void fn拨号() {
            Console.WriteLine("苹果手机, 拨号...");
        }

        public void fn上网() {
            Console.WriteLine("苹果手机, 上网...");
        }

        public void fn装app() {
            Console.WriteLine("苹果手机, 装app...");
        }
    }


    //谷歌手机, 也实现上面的接口
    class Cls谷歌手机 : Itf手机 {
        public void fn拨号() {
            Console.WriteLine("谷歌手机, 拨号...");
        }

        public void fn上网() {
            Console.WriteLine("谷歌手机, 上网...");
        }

        public void fn装app() {
            Console.WriteLine("谷歌手机, 装app...");
        }
    }



    //用户类
    class Cls消费者 {
        *private Itf手机 ins手机;  //有一部接口类型的手机*

        //构造函数
        *public Cls消费者(Itf手机 ins手机) {*
            this.ins手机 = ins手机;
        }

        public void fn用户使用手机() {
            this.ins手机.fn拨号();
            this.ins手机.fn上网();
            this.ins手机.fn装app();
        }
    }




    //主函数
    internal class Program {
        static void Main(string[] args) {

            *Cls消费者 ins消费者 = new Cls消费者(new Cls苹果手机()); //给用户实例, 传入一步实现了接口的苹果手机.*
            ins消费者.fn用户使用手机();

            //输出:
            // 苹果手机, 拨号...
            // 苹果手机, 上网...
            // 苹果手机, 装app...



            *Cls消费者 ins消费者2 = new Cls消费者(new Cls谷歌手机()); //给用户实例, 传入一步实现了接口的谷歌手机.*
            ins消费者2.fn用户使用手机();
            //输出:
            // 谷歌手机, 拨号...
            // 谷歌手机, 上网...
            // 谷歌手机, 装app...
        }
    }
}
----

*接口, 就是为了 class 与 class 之间"解耦合"的目的而生. +
但注意:当类实现一个接口的时候，class 与 interface 之间的关系也是“紧耦合”.*

'''

== 接口变量, 可以指针指向"任何实现了该接口的具体类的实例对象"

[,subs=+quotes]
----
//接口
internal *interface* InterfaceFly {
    public void fnFly();
    public void fn隐身();
}


//实现了该接口的 "Cls我"类
internal *class Cls我 : InterfaceFly  // 本类, 将要实现 InterfaceFly接口*
{

    public void fnFly() { //在本类中, 来具体实现"接口中定义的方法".      
        Console.WriteLine("Cls我, 这个类, 具体实现了 fly 方法");
    }

    public void fn隐身() {
        Console.WriteLine("Cls我, 这个类, 具体实现了 \"隐身\"方法");
    }
}


//实现了该接口的 "Cls别人"类
internal **class Cls别人 : InterfaceFly { //本类实现了该接口 **
    public void fnFly() {
        Console.WriteLine("Cls别人, 这个类, 具体实现了 fly 方法");
    }

    public void fn隐身() {
        Console.WriteLine("Cls别人, 这个类, 具体实现了 隐身 方法");
    }
}



//主函数
internal class Program {
    static void Main(string[] args) {
        *InterfaceFly v接口变量;  //这里,我们定义了一个接口变量, 让它可以指向"任何实现了该接口的具体类的实例对象".  即, 这个接口变量的指针, 指向那个类的实例, 就能调用该类实例中的方法.*

        *v接口变量 = new Cls我();  // 让接口变量,指向 "Cls我"类的实例.*
        v接口变量.fnFly(); //Cls我, 这个类, 具体实现了 fly 方法

        *v接口变量 = new Cls别人(); // 让接口变量,指向 "Cls别人"类的实例.*
        v接口变量.fn隐身(); //Cls别人, 这个类, 具体实现了 隐身 方法
    }
}
----

上面, v接口变量, 由于指向了不同的类的实例, 就能"变身"为不同角色, 执行不同功能. 这就是"多态" (多种形态).

image:img/0036.png[,]

'''


