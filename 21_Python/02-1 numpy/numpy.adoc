
:toc:
:toclevels: 3
:sectnums:


---

== 安装 numpy


.安装 numpy
[%collapsible]
====
pip3 install --user numpy scipy matplotlib

或用清华源: +
pip3 install numpy scipy matplotlib -i https://pypi.tuna.tsinghua.edu.cn/simple

pip3 install numpy scipy matplotlib -i https://repo.huaweicloud.com/repository/pypi/simple


- 清华大学：https://pypi.tuna.tsinghua.edu.cn/simple
- 华为云：https://repo.huaweicloud.com/repository/pypi/simple
- 阿里云：http://mirrors.aliyun.com/pypi

在使用pip的时候加参数-i
====


.测试是否安装成功
[%collapsible]
====
[source, python]
....
from numpy import *

print(eye(4)) # 会输出一个4阶单位阵
....
====



---

== 增

=== 创建 ndarray 数组 -> np.arange(num1, num2, num3, ...)

.创建 ndarray 数组
[%collapsible]
====

[source, python]
....
import numpy as np

# 方法1:
a1 = np.array([1,2,3]) # 创建ndarray数组
print(a1) # [1 2 3]
print(type(a1)) # <class 'numpy.ndarray'> ndarray 就是 numpy中 的数组类型

# 方法2:
a2 = np.array(range(10))
print(a2) # [0 1 2 3 4 5 6 7 8 9]

# 方法3:
a3 = np.arange(10)
print(a3) # [0 1 2 3 4 5 6 7 8 9]

a4 = np.arange(4,10,2) # 从4开始, 到不包括10, 步长为2
print(a4) # [4 6 8]
....
====


---

==





---

== 删

---

== 改

=== 修改数据的行列数 -> obj.reshape( (新行数,新列数) )

该方法, 输入一个tuple作为参数.

.将数组, 改成两层嵌套的 3行4列
[%collapsible]
====
[source, python]
....
a1 = np.arange(12)
print(a1.shape) # (12,)

a1 = a1.reshape((3,4)) # 进行修改, 改成3行4列
print(a1)

'''
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
 '''

print(a1.shape) # (3, 4)
....



====


.将数组, 改成三层嵌套
[%collapsible]
====
[source, python]
....
a1 = np.arange(24)
print(a1.shape) # (24,)

a1 = a1.reshape((2,3,4)) # 改成三层嵌套, 相当于是3维空间的.
'''
改成3层列表嵌套:
第一层是两个list,
第二层的每个list中, 又包含3个list.
第三层的每个list中, 又包含4个数值.
于是就共有 2*3*4 = 24个数值.
'''

print(a1)

'''
[[[ 0  1  2  3]
  [ 4  5  6  7]
  [ 8  9 10 11]]

 [[12 13 14 15]
  [16 17 18 19]
  [20 21 22 23]]]
 '''
....
====


.将三维数组, 重新改为二维数组
[%collapsible]
====
[source, python]
....
print(a1.shape) # (2, 3, 4) <- a1目前是三维数组, 有三层嵌套.

a1_2Dimension = a1.reshape((2,12)) # 重新改成2行12列,即二维空间中的值

print(a1_2Dimension)

'''
[[ 0  1  2  3  4  5  6  7  8  9 10 11]
 [12 13 14 15 16 17 18 19 20 21 22 23]]
'''

print(a1_2Dimension.shape) # (2, 12)
....
====


.将多维数组, 改成一维数组 (即只有一行, 只有一个list)
[%collapsible]
====
[source, python]
....
import numpy as np

a1 = np.arange(24)
a1 = a1.reshape((4,6)) # 先改成4行6列
print(a1.shape) # (4, 6)

a1 = a1.reshape((24,)) # 改回一维数组. 即将列表中的全部24个元素, 放在一个list中.
print(a1) # [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]
....
====


.将多维数组, 改成一维数组 -> 直接用 obj.flatten()方法
[%collapsible]
====
[source, python]
....
import numpy as np

a1 = np.arange(24)
a1 = a1.reshape((4,6)) # 先改成4行6列

a1_一行 = a1.flatten() # 将多维数组, 展开成一维的
print(a1_一行) # [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]
....
====

---

=== 给数组中的每个元素, 同时加上一个数字

.给数组中的每个元素, 同时加上(加减乘除)一个数字
[%collapsible]
====
[source, python]
....
import numpy as np

a1 = np.arange(10)
print(a1) # [0 1 2 3 4 5 6 7 8 9]

a2 = a1 + 5 # 将a1数组中的每个元素, 都加上5
print(a2) # [ 5  6  7  8  9 10 11 12 13 14]

a2 = a1 * 3 # 将a1数组中的每个元素, 都乘上3
print(a2) # [ 0  3  6  9 12 15 18 21 24 27]
....
====

---




---

=== 让两个数组, 对应元素相加

.让两个数组, 对应元素相加
[%collapsible]
====
[source, python]
....
import numpy as np

a1 = np.arange(6).reshape(2,3)
a2 = np.arange(100,106).reshape(2,3)

print(a1)
'''
[[0 1 2]
 [3 4 5]]
'''

print(a2)
'''
[[100 101 102]
 [103 104 105]]
'''


a3 = a1 + a2 # a1 和a2 数组中的 对应元素相加
print(a3 )
'''
[[100 102 104]
 [106 108 110]]
'''
....
====





== 查


=== 查看数据类型 -> obj.dtype

.查看数据类型 -> obj.dtype
[%collapsible]
====
[source, python]
....
a4 = np.arange(4,10,2) # 从4开始, 到不包括10, 步长为2
print(a4) # [4 6 8]

print(a4.dtype) # int32
....
====


---


=== 查看数据的行列数 -> obj.shape

.查看数据的行列数 -> obj.shape
[%collapsible]
====
[source, python]
....
a1 = np.array([[1,2,3],[4,5,6]])
print(a1.shape) # (2, 3) 两行三列
....
====


.查看数组数据的"行数"和"列数" -> obj.shape的返回值, 是个tuple, 第一个元素就是行数, 第二个元素就是列数.
[%collapsible]
====
[source, python]
....
import numpy as np

a1 = np.arange(24)
a1 = a1.reshape((4,6)) # 先改成4行6列

print(a1.shape) # (4, 6) <- 这是个元祖, 第一个数字是行数, 第二个数字是列数. 那么我们就能用索引, 来应用到它们了.

print(a1.shape[0]) # 4 <- 元祖中的第一个item, 是行数
print(a1.shape[1]) # 6 <- 元祖中的第2个item, 是列数

# 所以, 当我们不知道一个数组中到底有多少元素时, 也不知道它们被划分成了几行几列, 但我们想把它们变成一行, 就可以先查出它们的行数和列数, 就能知道: 元素总数 = 行数 * 列数.
a1_元素总数 = a1.shape[0] * a1.shape[1] # 行数 * 列数 = 一个数组中的元素总数
a1_oneLine = a1.reshape((a1_元素总数,))
print(a1_oneLine) # [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]
....
====




---














