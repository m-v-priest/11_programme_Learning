
= function函数
:toc:


== js中的函数本质

*从技术角度来说，函数永远不会“属于”一个对象*，所以把对象内部引用的函数称为“方法”似乎有点不妥。 +
确实，有些函数具有this 引用，有时候这些this 确实会指向调用位置的对象引用。但是这种用法从本质上来说, 并没有把一个函数变成一个“方法”，因为 *this 是在运行时根据调用位置, 动态绑定的，所以函数和对象的关系, 最多也只能说是间接关系。* +
如果属性访问返回的是一个函数，那它也并不是一个“方法”。属性访问返回的函数,和其他函数没有任何区别（除了可能发生的隐式绑定this，就像我们刚才提到的）。

//--------------------------
== 儿子(内函数)可以访问爸爸(外函数)的东西, 但爸爸不能访问儿子的东西
子(内函数)可以访问父亲(外函数)的执行环境, 但倒过来, 父亲不能访问到儿子孙子辈中的数据.

[source, typescript]
....
function fnFather() {
    let nameFather = 'zrx'

    return function fnSon() {
        console.log(nameFather); //zrx <--内函数,可以访问外函数的变量. 因为内部环境可以通过作用域链, 访问所有的外部环境
        let nameSon = 'zzt'
    }
    console.log(nameSon); //error TS2304: Cannot find name 'nameSon'. <--但外函数,无法直接访问其内函数中的变量.
}

fnFather()()
....

内函数可以访问外函数的变量 (子可以访问父亲的执行环境), 但反过来, 外函数无法访问其内函数中的变量.  即: 孙子权力最大, 爷爷权力最小. +
*每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链, 而进入另一个执行环境。*


当在某个环境中, 为了读取或写入而引用一个标识符(变量名)时，必须通过搜索来确定该标识符(变量名)实际代表什么。 +
搜索过程从作用域链的前端(即嵌套最内层)开始，向上(向嵌套外层)逐级查询与给定名字匹配的标识符(变量名)。 +
在这个搜索过程中，如果存在一个局部的变量的定义，则搜索会自动停止，不再进入另一个变量对象。换句话说，如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符.




内函数可以直接访问全局变量,和外函数中的变量, 而不需要将它们作为参数传入内函数中.




//--------------------------
== 默认值参数

==== 默认值参数, 必须放在最后一个
如果默认值参数不放在最后一个, 实际上你调用函数, 传参时, 是没法省略写这个参数的.

[source, typescript]
....
function fn1(x,y,z=101){}  //正确

function fn2(x, y=99, z) //错误写法
....

//--------------------------


== rest 参数, 用于获取函数的多余参数

ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。*rest 参数* 搭配的变量 *是一个数组*，该变量将多余的参数放入数组中。

[source, typescript]
....
function fn1(a: any, ...arrRestArgs: any[]) { //arrRestArgs就是一个真正的数组(而不是类数组).
    console.log(arrRestArgs)
}

fn1(1, 2, 3, 4, 5) //[ 2, 3, 4, 5 ]
....

---

==== reset是真数组, 而arguments是类数组
注意, *函数的arguments对象不是数组，而是一个类似数组的对象。* 所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。 +
rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。

---

==== reset参数必须在最后一个位置
注意，*rest 参数之后不能再有其他参数（即只能是最后一个参数）*，否则会报错。

[source, typescript]
....
// 报错
function f(a, ...b, c) {
    // ...
}
//SyntaxError: Rest parameter must be last formal parameter
....

//--------------------------

---

==== arguments.length 计值, 是不包含默认值参数的

如果函数的参数有默认值, 函数的length属性, 是不会将默认值参数计算在里面的, 只会计算没默认值的参数的数量.

[source, typescript]
....
function fn1(x, y, z = 101){
    print(arguments.length)
}

fn1(3,4) //2 <--虽然函数中有默认值参数z,但如果你传参时,省略这个默认值参数的话,它不会计算在你的函数实际收到的参数计数中.
....

*这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。* 同理，后文的 *rest 参数也不会计入length属性。*

//--------------------------

== 箭头函数

==== 不写{}的话, \=>箭头符号后面就直接就是返回值了, 不需要你再写return关键字了!
箭头函数的 return和{}大括号必须同时出现; 即不写大括号的话, 直接就是返回值, 而不需要再写return关键词.


[source, typescript]
....
let arr = ['zrx', 19, true]
let arr_ItemType = arr.map(item => Object.prototype.toString.call(item)) //箭头=>后面没有大括号{}, 就表示箭头后面的内容直接就是返回值了!
console.log(arr_ItemType); //[ '[object String]', '[object Number]', '[object Boolean]' ]
....


//--------------------------

---

==== 箭头函数, 如何返回一个obj对象
由于大括号{}被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上小括号()包裹起来，否则会报错。

[source, typescript]
....
let fnCreateInsPerson = (name: string, age: number, isFemale: boolean) => ({name: name, age: age, isFemale: isFemale}) //注意: 箭头函数要想直接返回一个对象字面量, 必须用小括号()把这个对象包裹起来, 否则,js会把这个{}大括号, 理解成是箭头函数的函数体的包围括号{}

let p1 = fnCreateInsPerson('zzr', 19, true)
console.log(p1); //{ name: 'zzr', age: 19, isFemale: true }
....

//--------------------------

---

==== 箭头函数没有自己的this，其内部的this绑定到它的外围作用域

函数体内的this对象，就是定义该箭头函数时, 所在的对象，而不是使用该箭头函数时所在的对象。换句话说, this对象的指向, 在箭头函数中，它是固定的。 +
this指向的固定化，并不是因为箭头函数内部有绑定this的机制，*实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。*

*箭头函数没有自己的this，其内部的this绑定到它的外围作用域。* 对象内部的箭头函数若有this，则指向对象的外围作用域。 所以, *当你在一个对象p1内部的方法中的this, 永远指向该方法外围(即对象p1)的作用域!* 相当于是绑定了p1为上下文环境!





---

==== 箭头函数不能用作构造函数
正是因为箭头函数它没有this，所以也就不能用作构造函数。也就是说，不可以使用new命令，否则会抛出一个错误。

---

==== 箭头函数中没有arguments对象, 只有rest参数
不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。

---

==== 箭头函数不能用作 Generator函数
不可以使用yield命令，因此箭头函数不能用作 Generator 函数。

---

== 自执行函数 (在定义了函数体后, 立刻自动执行, 而不需要手动调用函数)

   写法是: 用小括号()将整个函数定义包起来（将函数作为一个表达式），然后传入需要使用的参数。如下:

   [source, typescript]
   ....
   (function fn() {
       console.log(参数)
   }(参数))
   ....

   或

   [source, typescript]
   ....
   (function fn() {
       console.log(参数)
   })(参数)
   ....


---



//--------------------------

== 获取函数名的string形式
函数的name属性，会返回函数名.

[source, typescript]
....
function fn(): void {
}

console.log(fn.name); //fn
....



